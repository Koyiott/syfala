\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[francais]{babel}
\usepackage[french]{babel}
\usepackage{eurosym}
\usepackage{lmodern}
\usepackage{boxedminipage}
\usepackage{moreverb}
\usepackage{microtype}

\usepackage[pdftex]{graphicx}
\graphicspath{{./fig/}}
\usepackage[colorlinks,linkcolor=blue,citecolor=blue,pagebackref]{hyperref}
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}
\usepackage[usenames,dvipsnames]{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{pgfgantt}
\usepackage{multicol}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{tikz}
\usetikzlibrary{calc, arrows, shapes, fit}
\usetikzlibrary{positioning,intersections}
\usepackage{pgfplots}
\pgfplotsset{compat=1.8}

%for timing diagrams
% tikz for chronogram
\usepackage{tikz-timing}

%-----------------------------------------------------------------------
\usepackage[
text={15cm,21cm},
centering,
% showframe,
]{geometry}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
%\renewcommand{\theequation}{\thesection.\arabic{equation}}
%\renewcommand{\thetable}{\thesection.\arabic{table}}

%-----------------------------------------------------------------------
% The following macros determine the part of the text that will actually
% be compiled. When the paper is completed, set all the macros to 0.

\def\withtoc{0}
   % "with table of contents (TOC)"
   % 0: without TOC
   % 1: with TOC

%-----------------------------------------------------------------------

\newcommand{\CAD}{c.-\`a-d.}
\newcommand{\PEX}{p.\,ex.}
\newcommand{\tocvspace}{-2.0ex}
\usepackage{xspace}
\newcommand{\syfala}{{Syfala}\xspace}
\newcommand{\todo}[1]{\footnote{#1}}

%-----------------------------------------------------------------------


\newcommand{\tcb}{\textcolor{blue}}
\newcommand{\tcg}{\textcolor{OliveGreen}}
\newcommand{\red}{\textcolor{red}}

\newcommand{\knownbug}[1]{\red{WARNING KNOWN BUG: #1}}

\newcommand{\adtname}{SytaRiot}

%-----------------------------------------------------------------------
\title{\Large\bf Getting started with the Syfala project: \\ From Faust to FPGA}
\author{Tanguy Risset, Maxime Popoff and the Syfala Team}
\date{\today}
\begin{document}
\maketitle

\tableofcontents

\setcounter{section}{-1}
\newpage
\section{Very Quick Start}
Last update of this document: \today

\paragraph{Most recent version:} Syfala v6.3 (os2) uses, Vivado 2020.2 and Faust 2.39.3\\

\begin{boxedminipage}{1.03\textwidth}
  \begin{verbatim}
    #make sure that vivado (v=2020.2) and Faust (v>2.39.3) are installed
    #on your computer
    git clone https://github.com/inria-emeraude/syfala.git  my-clone-syfala
    cd my-clone-syfala/syfala
    make
    # connect the Zybo by USB with SW0 switched on LD0 side and
    # blue jumper on JTAG
    make boot
    #listen to audio ``HPH OUT''
\end{verbatim}
\end{boxedminipage}

~\\

Syfala has been started almost two years ago, a first preliminary presentation was done at IFC 2020~\cite{Risset20}. A more recent publication shoudl appear at SMC2022. There has been a number of {\em version} of Syfala, each {\em version} implying great changes in the sources file, and tools used hence requiring a new source code. Initial development were performed on internal Inria gitlab site (\url{https://gitlab.inria.fr/risset/syfala}). Since feb. 2022 a public github syfala site has been opened (\url{https://github.com/inria-emeraude/syfala}). The current version released (previously in directory {\tt v6.3-os2}, renamed {\tt syfala} in public github) makes the following choices:
\begin{itemize}
\item One-sample strategy: the FPGA DSP kernel is launched at each new sample and the result is available before the arrival of the next sample
\item No use of pentalinux. The software running on the ARM of the Zynq SoC is used {\em bare-metal}: no operating system is present.
\item The DDR3 memory is accessed by the FPGA DSP kernel, allowing to have long delay lines in DSP programs implemented. The DDR3 is also accessed in a {\em bare metal} manner: no MMU is used.
\item The whole design has been optimised for low latency, efficient memory accesses, and software initialisation  (see SMC2022 paper).
\item The FPGA DSP kernel can be controled with a harware interface or a software interface. The software interface is using the serial port UART between the host processor and the ARM on the Zynq. The hardware interface use SPI interface to knobs and slider, an open hardware board design is available on github/emeraude organisation).
\end{itemize}
\newpage

\section{Syfala v6.3 compilation flow}
\label{syfala1}
The required tools installations ({\tt vivado, vitis, vitis\_hls, Faust}) are explained in Annex~\ref{install}. In the cloned directory, Syfala compilation flow is deployed in a subdirectory: version v6.3 is available in directory {\tt syfala}. Here are the ways to compile your first Faust IP: \\

\begin{boxedminipage}{\textwidth}
  \begin{verbatim}
    git clone https://github.com/inria-emeraude/syfala mysyfala
    cd mysyfala/syfala
    make
\end{verbatim}
\end{boxedminipage}

~\\

or if you have installed your ssh key on github:\\

\begin{boxedminipage}{\textwidth}
  \begin{verbatim}
    git git@github.com:inria-emeraude/syfala.git mysyfala
    cd mysyfala/syfala
    make
\end{verbatim}
\end{boxedminipage}

~\\

The  \syfala compilation flows v6.3 follow the schematics of Figure~\ref{fig1}. The default configuration when cloning syfala github code attemps to compile a Faust program called {\tt virtualAnalog.dsp} which is present in the the {\tt mysyfala/faust} directory and  is configured to use a {\em software} control interface (i.e. not a hardware control interface).

The parameters of the compilation launched by the {\tt make} command can be modified in the {\tt Makefile} file (name of DSP program compiled) or in the {\tt configFAUST.h} file (harware/software interface, codec used etc.). The successive commands called by the {\tt make} command above are the following:\\

  \begin{boxedminipage}{\textwidth}
  \begin{verbatim}
    faust -lang c -light -os2 -a fpga.cpp -uim -mcd 0 -o faust_v6.cpp \
        ../faust/virtualAnalog.dsp
    vitis_hls -f ../scripts/ip_v6.tcl
    vivado -mode batch -source scripts/project_v6.tcl -tclargs 
    faust -i -lang cpp -os2 -mcd 0 -a arm.cpp ../faust/virtualAnalog.dsp \
        -o faust_v6_app.cpp
    xsct ./scripts/application_v6.tcl
\end{verbatim}
\end{boxedminipage}

  ~\\
  The same result can be equivalently obtained by performing each step individually with the following commands:\\

  \begin{boxedminipage}{\textwidth}
  \begin{verbatim}
    make faust /* makes the faust_v6.cpp file */
    make ip /* uses vitis_hls to synthesize faust_v6.cpp */
    make project /* build the faust_v6.xpr vivado project */
    make bitstream /* execute the vivado faust_v6.xpr project */
    make app /* create and compile the control application */
    make boot /* dwnld bitstream+app on Zynq (JTAG) and boot*/
    make controlUI /* launch the control UI on the host computer */
\end{verbatim}
\end{boxedminipage}
  
\begin{figure}[h]
  \begin{center}
    \input{fig/compilerOverview.tex}
    \end{center}
  \caption{Syfala compilation flow, grey boxes are generated during the compilation flow}
  \label{fig1}
\end{figure}

The choices that have been made Syfala v6.3 are the following:
\begin{itemize}
\item Implement a {\em one sample} flag in the Faust compiler ({\tt -os2}) that generates a {\tt computemydsp} function of the {\tt faust.cpp} file that computes only one sample. It implies that the FPGA signal processing treatment is not pipelined among the audio samples.
\item Have a fixed interface of the {\tt faust} IP that will be synthesized by {\tt vitis\_hls}.  This interface is present in the architecture file {\tt fpga.cpp} detailled in Section~\ref{sec:fpga}
\item Have a fixed software running on the ARM, performing constants and delays initialization and then constantly updating controllers -- using hardware or software interface -- and sending them to the IP. This {\em application} uses the {\tt arm.cpp} architecture file and  is described in Section~\ref{sec:arm}    
\end{itemize}
  
\subsection{The Faust IP and the {\tt fpga.cpp} architecture file}
\label{sec:fpga}
The {\tt fpga.cpp} file is the Faust {\em architecture file} for Xilinx  FPGA target  (currently only Xilinx FPGA architectures are supported by syfala). The {\tt fpga.cpp} determines the interface of the Faust IP. It is important to understand this interface because it highly influences many performances issues. Changing this interface is possible but it implies to change all vivado scripts present in the compilation flow, hence it requires many manual tuning before getting to new automatic compilation flow with a new interface of the Faust IP. 

The interface of the Faust IP is determined by the parameter of the {\tt faust\_v6()} function which is the function synthesized by {\tt vitis\_HLS}. The prototype of the {\tt faust\_v6()} function,  extracted from the {\tt fpga.cpp} file is shown in Fig.~\ref{fig:interface}, HLS pragmas indicate how each parameter of the IP are interfaced with the rest of the system. The  following conventions are used (see {\tt faust\_v6.cpp} file generated in the {\tt build/faut\_ip} directory):

\begin{figure}
\begin{boxedminipage}{\textwidth}
    \small
\begin{verbatim}
void faust_v6(ap_int<DATA_WIDTH> in_left_V, ap_int<DATA_WIDTH> in_right_V, 
        ap_int<DATA_WIDTH> *out_left_V,ap_int<DATA_WIDTH> *out_right_V,
        FAUSTFLOAT *ram,  bool *outGPIO1, bool *outGPIO2,
        bool debugSwitch, int ARM_fControl[16], int ARM_iControl[16], 
        int DEBUG_toIP_tab[32], int ARM_passive_controller[32], 
        int soft_reset, int ramBaseAddr, int ramDepth, 
        int userVar, bool enable_RAM_access)
{
#pragma HLS INTERFACE s_axilite port=ARM_fControl
#pragma HLS INTERFACE s_axilite port=ARM_iControl
#pragma HLS INTERFACE s_axilite port=ARM_passive_controller
#pragma HLS INTERFACE s_axilite port=DEBUG_toIP_tab
#pragma HLS INTERFACE s_axilite port=soft_reset
#pragma HLS INTERFACE s_axilite port=ramBaseAddr
#pragma HLS INTERFACE s_axilite port=ramDepth
#pragma HLS INTERFACE s_axilite port=userVar
#pragma HLS INTERFACE s_axilite port=enable_RAM_access
#pragma HLS INTERFACE m_axi port=ram latency=50
  [....]
  }
\end{verbatim}
\end{boxedminipage}
\caption{Prototype of the {\tt faust\_v6()} function defined in the {\tt fpga.cpp} architecture file. This function is synthesized by {\tt vitis\_hls} to generate the Faust IP}
\label{fig:interface}
\end{figure}
  

\begin{itemize}
\item Stereo input and output  (i.e. \verb#in_left_V#, \verb#in_right_V#, \verb#out_left_V#, \verb#out_right_V#) are 24 bit wide signed integer between -1 and 1, which are to be send and receive from the I2S transceiver which himself will interface with the audio codec. The sample bit depth can be changed in the file {\tt configFAUST.h}
  \item All other parameters of the IP are transmitted from the ARM processor via the {\tt s-AXI} protocol, except the {\tt ram} parameter which is the access to thr DDR3 memory. 
\item The DDR3 memory is accessed via the m-AXI protocol in a {\em bare metal} manner: a memory zone is reserved by the ARM program (explicitely reserved in the linker script) and the address and size of this zone are transmitted to the IP via the {\tt ramBaseAddress} and {\tt ramDepth} parameters. Note the {\tt latency=50} pragmas which indicate that we {\em estimate} that a memory access will take 50 FPGA clock cycle (tuned at 120Mhz), this estimate is used by {\tt viti\_hls} to produce estimation of the timing performance of the IP (file {\tt faust\_v6.rpt}), but it is only an estimation of course.
\item {\tt ARM\_icontrol[16]} and {\tt ARM\_fControl[16]} arrays are used to transmit controllers values (integer values or floating point controllers) from ARM to IP, hence in this version there must be less than 16 controllers of each type, but these can be changed before compilation of course.
\item {\tt useVar}, {\tt DEBUG\_toIP\_tab[16]}, {\tt ARM\_passive\_controller[16]}, {\tt outGPIO1} and {\tt outGPIO2} can be used for debugging purpose.
\item {\tt enable\_RAM\_access} is a boolean that indicates to the IP that the DDR3 initialisation performed by the ARM are finished and the the IP can start to access the DDR3.
\end{itemize}

the body of the {\tt faust\_v6()} function is shown in Fig.~\ref{fig:body}. The {\tt computemydsp()} function is the function computing the effective signal processing on input/output, it is generated by the Faust compiler in the {\tt faust\_v6.cpp} file.

\begin{figure}

\begin{boxedminipage}{\textwidth}
    \small
\begin{verbatim}
void faust_v6([...])
{
if (enable_RAM_access) {
    if (cpt==0) {
      cpt++:
      /* Download initialization of constants from DDR3 content */
      instanceConstantsFromMemmydsp(&DSP,SAMPLE_RATE,I_ZONE,F_ZONE);
    }
    else {
        /* compute one sample */
        computemydsp(&DSP, inputs, outputs, icontrol, fcontrol, I_ZONE, F_ZONE);
      } 
  /* Copy produced outputs, scaleFactor cast between float and ap_int */
    *out_left_V = ap_int<DATA_WIDTH>(outputs[0] * scaleFactor);
    *out_right_V = ap_int<DATA_WIDTH>(outputs[1] * scaleFactor);
}
\end{verbatim}
\end{boxedminipage}
\caption{Body of the {\tt faust\_v6()} function synthesized by {\tt vitis\_hls} to generate the Faust IP}
\label{fig:body}
\end{figure}


The {\tt scaleFactor} value (i.e. {\tt 8388608.0f}) is exactly $2^{23}$. The input/output of the {\tt \bf faust} function are arrays of type {\tt ap\_int<24>}, i.e. signed integer of 24 bit, they are interpreted as {\em decimal part of signed samples between -1 and 1}.

The following table shows the correspondence between the floating point values output by the {\tt computemydsp} function and the corresponding sample input to the I2S transceiver:
{\small
  \begin{tabular}{|c|c|c|c|}
  \hline
  Faust {\tt output} Float  & value truncated  & value stored in  & 24 bits representation of $c$\\
  sample value ($a$) & for {\tt 24 bits} ($b$) &   {\tt out\_left\_V} ($c$)  & sent to i2s  \\
  \hline 
  $0.12345678123456$ & $0.1234567$ & $c=a*2^{23}=1035630$ & [000011111100110101101110] \\
  \hline
$-0.12345678123456$ & $-0.1234567$ & $c=a*2^{23}=-1035630$ & [111100000011001010010010]\\
\hline
\end{tabular}
}


\subsection{Interfacing Faust IP and audio codec: I2S}
\begin{figure}[ht]
  \centerline{\includegraphics[width=16cm]{design_v6_3.pdf}}
  \caption{The bloc design obtained by connecting Faust IP,(\syfala v6.3), with I2S IPs and m-AXI interface to DDR3}
  \label{fig:design_6_3}
\end{figure}

Figure~\ref{fig:design_6_3} shows how the Faust IP, is interconnected with the rest of the system. All these IPs have a hardwired system clock at approximately 120Mhz (i.e. 8.33ns system clock). It is very easy and very useful to open the {\tt vivado} project that generates the design. This can be done with the following commands:\\
\begin{verbatim}
make project
vivado build/faust_v6_project/faust_v6_project.xpr
\end{verbatim}
Then the  block design shown on Fig.~\ref{fig:design_6_3} can be opened using {\tt open Block Design}. One can see that the audio input/output streams of the Faust IP are directly connected to the I2S IP ({\tt i2s\_transceiver} block), one can also see the {\tt m\_axi} IP interface which is used to access DDR3 and the {\tt s\_axi} IP interface used for interface with ARM processor.  The I2S IP is in turn directlly connected to I/O of the Zynq board corresponding to the codec interface. The codec (by default the Zybo Board  integrated codec: Analog Device SSM2603) is configured from the ARM processor as described in section~\ref{sec:arm}



%\subsubsection{The {\tt i2s\_transceiver} IP}

%% \begin{figure}[ht]
%%   \centerline{\includegraphics[width=\textwidth]{i2s_serialbit_mode.png}}
%%   \caption{J'ai laissé cette figure pour qu'on s'en inspire pour finit l'autre diagramme}
%%   \label{figi2sold}
%% \end{figure}


\begin{figure}[ht]
  \input{fig/clock_i2s.tex}
  \caption{I2S  protocol implemented {\tt i2s\_transceiver.vhd}, between the Faust IP and  the audio codec SSM2603 with 16-bit samples. The {\tt ws} signal select from left or right channel. The {\tt  sd\_tx} bit stream corresponds to the 16 bits of the sample. it is shifted of 1 clock cycle from {\tt ws} changes. {\tt bclk} stands for {\em bit clock} and {\tt ws} stands for {\em word select}.}
  \label{figi2s}
\end{figure}

\begin{figure}[ht]
  \input{fig/clock_i2s_zoom1.tex}
  \caption{Zoom on the beguinning of a right sample  (sample number $i$) first bits transmission: {\tt mclk} is 4 time faster than {\tt bclk}. {\tt ws\_tx} and {\tt ws\_rx} are delayed version of {\tt ws}, used to synchronize starting of  samples bits transmission. {\tt sd\_tx} is {\em produced} by the I2S IP as an output on the falling edge of {\tt bclk} and {\tt sd\_rx} is {\em read} as an input on the rising edge of {\tt bclk}.}
  \label{figi2szoom1}
\end{figure}

The {\tt i2s\_transceiver} is the one that really transmit the bits between the FPGA and the audio codec. The data is serialized and transmitted/received on the {\tt sd\_tx}/{\tt sd\_rx} port to {\tt recdat/pbdat} ports of the SSM2603 audio codec. The protocol used in our design is the one illustrated on Fig.~\ref{figi2s}, it can be configured to send 16, 24 or 32 bit-wide sample. For 16 bit configuration the sample cycle time is exactly divide in 32 cycle to transmit the $2\times16$ bits (left and right samples), as shown on Fig.~\ref{figi2s}. But for 24 bit-wide sample, the sample cycle is not divided in 48 (=$2\times24$), but in 64 cycles as it is for 32  bit-wide samples.  The sample bits are serially transmitted along the {\tt bclk} clock as shown in Fig.~\ref{figi2s} (see also~\cite{ssm2603}). The {\tt ws} signal indicates whether current bits belong to  left or right channel. However, as indicated in Fig.~\ref{figi2s}, there is a shift of 1 cycle: the first bit send after {\tt ws} clock falldown is not the first bit of current left sample, it is the last bit of the previous right sample.\footnote{See for instance \url{https://www.sparkfun.com/datasheets/BreakoutBoards/I2SBUS.pdf}}

\paragraph{Syfala I2S patch} In a normal transmission, the {\tt sd\_tx} bit is positionned on the falling edge of {\tt bclk} clock, it is transmitted from our (master) I2S to the (slave) I2S of the codec. Simultaneously, the slave I2S is positionning the {\tt sd\_rx} bit -- which is {\em his} {\tt st\_tx} -- to be transmitted from the codec to our I2S. The {\tt sd\_rx} bit is effectively read by our I2S on the rising edge of {\tt bclk}, this allows time for the signal to arrive through the connection between the codec and the FPGA, this time is called {\tt Tsod} in analog device ADAUs codecs for instance (see Fig.~\ref{figi2szoom2}-(a) for illustration).  

In our design, we have used external codecs that allows internal clock as fast as 768kHz. We have noticed that, as we needed a level shifter to adapt power supplies between the codec and the Zybo, this  half a bclk cycle time may be less than the time needed for {\tt sd\_rx} to stabilize. Hence we proposed a {\em patch} that delays of one  {\tt mclk} cycle in addition to the half {\tt bclk} cycle shown on Fig.~\ref{figi2szoom2}-(b).

\begin{figure}[ht]
  \begin{tabular}{cc}
    \begin{boxedminipage}{0.5\textwidth}
      \input{fig/clock_i2s_zoom2.tex}
      \end{boxedminipage} &
    \begin{boxedminipage}{0.5\textwidth}
      \input{fig/clock_i2s_zoom3.tex}
            \end{boxedminipage}\\
  (a) Standard I2S & (b) Patched I2S \\
  \end{tabular}
  \caption{The left chronogram (a) illustrates the {\tt Tsod} time needed for the information to tansit from codec to FPGA. In a standard I2S, the {\tt sd\_rx} bit is sampled on the rising edge of {\tt bclk}. On the right (b) is illustrated our patch delaying the sampling of a {\tt mclk} period, taking into account the time needed to transit through the level shifter}
  \label{figi2szoom2}
\end{figure}

We have implemented the I2S protocole in VHDL (file {\tt src/i2s\_transceiver.vhd}). It can be parameterized by the  sample bit depht as well as by the sample rate.  

The {\tt i2s\_transceiver} is connected to the {\tt faust} IP . It performs a hand shake ({\tt ap\_hs} protocol from Xilinx {\tt vitis\_hls}) with the Faust IP in order to transmit and receive samples from the Faust IP. The {\tt ap\_start} signal is initiated by the {\tt i2s\_transceiver} and when the two Faust IP output are ready ({\tt out\_left\_V} and {\tt out\_right\_V}), the signals {\tt out\_left\_V\_ap\_vld} and {\tt out\_right\_V\_ap\_vld} are raised {\em for one system clock cycle}. A hand shake is proposed in the I2S transceiver to grab the output values when they are available (they are not necessarily available simultaneously). 


\subsection{Time, Clocks and the ordering of ticks in the Syfala system}

It is important to understand the origin and value of the different clocks in the system. The generation of the different clocks is highly simplified by the use of the {\tt Clocking Wizard} IP, which itself inputs the FPGA system clock ({\tt sys\_clk}) and output the required clocks.  
\paragraph{FPGA system Clock: 120Mhz}
The {\em internal} FPGA clock that triggers every registers of the FPGA is depending of the complexity of the design (i.e. the complexity of the longest combinatorial path), it is called {\tt sys\_clk} on Vivado block design. We usually impose this clock to be {\bf 120Mhz} (i.e. setting approximately a {\bf 8.33ns} clock when creating {\tt vivado} and {\tt vivado\_hls} projects). If {\tt vivado} fails in synthesizing a design that can be clocked at that speed, it will issue an error message, however it should be easy to change this clock to another value as all other clocks are generated independently of this one.

\paragraph{Audio codec internal Master Clock: $ 2\times 4 \times d_{width}\times f_s$}
We call $d_{width}$ the number of cycle needed to send the bits of one sample,  remember that, as explained above: $d_{width}$ is 16 for 16 bit-wide samples but 32 for 24 bit wide samples (and 32 for 32 bit wide samples too).   
The clock regulating the SSM2603 ({\tt mclk}) should be a multiple of the sampling frequency, it should be exactly $f_{mclk}=2\times 4\times d_{width}\times f_s$, where $f_s$ is the sample rate. Indeed, as $bclk$ clock will be four times  slower than $mclk$ clock, we will have time to send 2 samples of $d_{width}$ bits in one sample cycle. 

For instance, if  we configure the chip to run with 48kHz sampling rate with 24 bit samples, $f_{mclk}$ should be: $$f_{mclk}=8 \times 32 \times f_s=256*48kHz =12.288MHz$$

In out design, this clock is generated with the {\tt clocking Wizard} IP and transmitted to both {\tt i2s\_transceiver} and {\tt ssm2603}  codec to ports name {\tt mclk}.

\paragraph{Vivado IP's clocks}
The AXI bus and the Zynq processing system require a 100Mhz clock. The Zynq processing system requires also a 50Mhz clock\todo{To be checked, on most recent syfala version, no such clock is generated}


\paragraph{The {\tt i2s\_transceiver} clocks}
The I2S transceiver is using two more clocks: the {\bf sclk} clock, sometimes called  {\bf bclk} ({\em bit clock} because it is clocking each bit as illustrated on figure~\ref{figi2s}) and the {\bf ws} clock (word select) which select the left or right channel (illustrated as {\tt ws} on Fig.~\ref{figi2s}).

There is a fixed ratio between these two clocks and the {\tt mclk} mentioned above:{\tt mclk/sclk}=4 (i.e. {\tt mclk} is 4 time faster {\tt sclk}). The ration between {\tt sclk} and {\tt ws} is also fixed but it depends on the bit depth of the sample: {\tt sclk/ws}$=2\times d_{width}$. We have hard-coded these ratios  in {\tt i2c\_transceiver.vhd} generic VHDL parameters which are generated at compile time, depending on the sample bit-depth choosen in the file {\tt configFAUST.h}

For instance, at  48kHz sampling rate with 24 bit samples,  one {\tt ws} period is $T_{ws}=4\times 2\times 32\times T_{mclk}=256\times T_{mclk}=T_{audio}=\frac{1}{48kHz}=20.83\mu s$. Here are the generic parameters used for this configuration in {\tt i2s\_transceiver.vhd}

{\small
\begin{verbatim}
  generic(
    mclk_sclk_ratio : integer := 4;   --number of mclk periods per sclk period
    sclk_ws_ratio   : integer := 64;  --number of sclk periods per word select period
    d_width         : integer := 24); --data width
\end{verbatim}
}

Hence,


\begin{figure}[ht]
  \centerline{\includegraphics[width=7cm]{zynq-mp-core-dual1.png}}
  \caption{Architecture of Xilinx Zynq processing system (from \url{https://www.rs-online.com/designspark/getting-started-with-xilinx-zynq-all-programmable-soc})}
  \label{zynq}
\end{figure}

\subsection{The ARM application software  and the {\tt arm.cpp} architecture file}
\label{sec:arm}

Zynq FPGAs include a so-called {\em processing system} which consists in a complete SoC integrating $i)$ a dual core ARM CorteX A9 processor, $ii)$ the FPGA fabric, $iii)$ high performance and general purpose buses between ARM and FPGA (s-AXI port) and $iv)$ an interface to an external DDR3 memory (see Fig.~\ref{zynq}). Ideally,  the DSP computations should be executed on the FPGA and the control and initialization should be executed on  the ARM processor.  The Faust language proposes several interfaces to the user: sliders or button and even feedback information. In the remaining of this documents, we will refer to these interface devices as {\em controllers}.  





The {\tt faust}  compiler is invoqued a second time. The first invocation  has generated the {\tt faust\_v6.cpp} file used to generate the IP as in Syfala version 1 (using the {\tt fpga.cpp} architecture file). The second invocation is used to generate the {\tt faust\_v6\_app.cpp} program that will run on the ARM (using the {\tt arm.cpp} architecture file).


The   {\tt faust\_v6\_app.cpp} is quite long because it re-uses many contributions from the Faust ecosystem. Here are the actions executed by the application on the ARM processor (i.e. the actions of the {\tt faust\_v6\_app.cpp} file):
  \begin{itemize}
  \item It initializes the {\tt ddr\_ptr} pointer to the DDR memory and erases the part of the memory used by the FPGA IP. The address of the {\tt ddr\_ptr} is  heritated from a macro defined in the linker script: 
\begin{verbatim}
    u32* ddr_ptr = (u32*)FRAME_BUFFER_BASEADDR;
\end{verbatim}

\item it initializes the {\tt izone} and {\tt fzone} which are then transmitted to the Faust IP:
\begin{verbatim}
        iZone = (int*)(ddr_ptr);
        fZone = (float*)(ddr_ptr + FAUST_INT_ZONE);
\end{verbatim}
\item it initialize various peripherals of the Soc:
  \begin{itemize}
  \item GPIOs
  \item SPI peripheral (used to get controlers/sliders valuers)
  \item I2C (used to configure the audio codec)
  \item Faust IP
  \item DDR3 memory
  \end{itemize}
\item It defines a user interface for the DSP program ({\tt UI})
\item It defines a class {\tt mydsp} which correspond to all the variables of the DSP program  stored in the Block Rams by the Faust IP: delay lines, temporary computation, etc. This ``additionnal'' declaration is used to initialize some of these variables (in particular constants).
  \item It maintains a state for each controller and updates them when their values changes, either from hardware (in case of hardware interface) or from software (i.e. via the UART connection in case of software interface).
  \item It sends these controllers values repetitively to the Faust IP.
  \end{itemize}
\begin{figure}[ht]
\centering
  \begin{tabular}{ccc}
    \input{fig/interfaceOverview.tex}&~~~~ &
    \includegraphics[width=4cm]{fig/popophone.jpg}\\
    (a) & &(b)
    \end{tabular}
\caption{(a) Interface selection between software interface (GTK app) and hardware interface (knobs such those shown in (b)). The design of the hardware board such as (b) can be freely available on github.}
\label{fig:interfaceOverview}
\end{figure}
  The {\tt faust\_v6\_app.elf} file is cross-compiled to ARM binary format on the host using the cross compilation tool proposed by {\tt vitis} from the files {\tt faust\_v6\_app.cpp}, and some other files present in the {\tt src} directory. The compilation is configured by Xilinx {\tt xsct} tool using the script {\tt scripts/application\_v6.tcl}

Depending on the information written in the {\tt configFaust.h} file, the code executed by {\tt faust\_v6\_app.elf} launches a hardware interface to control the Faust IP or a software interface to control the Faust IP. This is shown on Fig.~\ref{fig:interfaceOverview}


\section{A complete example: simple sinewave}
\input{sin-example.tex}

\bibliographystyle{plain}
\bibliography{syfala-getting-started.bib}


\newpage
\appendix
\label{Annex1}
      
\input{body-install-toolchain.tex}

\section{Known bugs: Important ``tricks'' to be known!!}
\label{bug}

This section regroups all the tricks that can result in unlimited waste of time if not known

\subsection{Locale setting on linux}
\label{localSetting}
\knownbug{it is a known bug that {\tt vivado} is sensible to the ``locale'' environment variable on linux, hence you have to set these variables in your {\tt .bashrc} file:\\
\tt export LC\_ALL=en\_US.UTF-8\\
export LC\_NUMERIC=en\_US.UTF-8
}

If you do not, you might end up with unpredictible behaviour of Vivado.

\subsection{Patch 2022 date bug}
\label{2k22patch}
\knownbug{Vivado and Vitis tools that use HLS in the background are also affected by this issue. HLS tools set the ip\_version in the format YYMMDDHHMM and this value is accessed as a signed integer (32-bit) that causes an overflow and generates the errors below (or something similar).}

Follow this link: \url{https://support.xilinx.com/s/article/76960?language=en_US}

Download the file at the bottom of the page and unzip it in your Xilinx base install directory (Xilinx file where you have your Vitis,Vitis\_HLS and Vivado files). 

DONT FOLLOW THE README... Just check the "Known Issues:" section on the Xilinx page which takes over the readme.

From the Xilinx directory, run:
\begin{itemize}
\item export LD\_LIBRARY\_PATH=\$PWD/Vivado/2020.2/tps/lnx64/python-3.8.3/lib/
\item Vivado/2020.2/tps/lnx64/python-3.8.3/bin/python3 y2k22\_patch/patch.py
\end{itemize}

\subsection{Save the Vivado Install file in case of installation failure}
\label{installSave}

Vivado installation tends to fail. To avoid having to redownload the installation file each time you try , we suggest to use the “ Download Image (Install Separately)” option. It creates a directory with a xsetup file to execute for installing. But don't forget to duplicate the installation file, because Vivado will delete the xsetup installation file you use if you choose to let him delete all files after the installation failed.
%Oui alors c'est pas clair....
\subsection{Vivado Installation stuck at "final processing: Generating installed device list"}
If the install of Vivado is stuck at "final processing: Generating installed device list", cancel it and install the libncurses5 lib:
\begin{verbatim}
sudo apt install libncurses5
\end{verbatim}

\subsection{Installing Vivado Board Files for Digilent Boards}
It is necessary, once Vivado install, to add support for new digilent board.
the content of directory {\tt board\_files } has to be copied in \verb#$vivado/2019.2/data/boards/board_files#
(see \begin{verbatim}https://reference.digilentinc.com/learn/programmable-logic/tutorials/\ 
    zybo-getting-started-with-zynq/start?redirect=1#
\end{verbatim}
The content of {\tt board\_files } can be obtain by typing, in syfala source directory:     \verb#git submodule update --init#\footnote{TODO: check, ca marche ça?)}

Or directly here: \url{https://github.com/Digilent/vivado-boards}

\subsection{Cable drivers (Linux only)}
For the Board to be recognized by the Linux system, it is necessary to install additional drivers. See \url{https://digilent.com/reference/programmable-logic/guides/install-cable-drivers}


\subsection{Digilent driver for linux}
On some linux install, programming the Zybo board will need to install an additionnal ``driver'': Adept2 \url{https://reference.digilentinc.com/reference/software/adept/start?redirect=1#software_downloads}

\subsection{Vitis installation}
{\bf Warning} Apparently the installation process does not end correctly if the {\tt libtinfo-dev} package is not correctly installed (\url{https://forums.xilinx.com/t5/Installation-and-Licensing/Installation-of-Vivado-2020-2-on-Ubuntu-20-04/td-p/1185285}. In case of doubt, execute these commands (april 2020):
\begin{verbatim}
sudo apt update
sudo apt install libtinfo-dev
sudo ln -s /lib/x86_64-linux-gnu/libtinfo.so.6 /lib/x86_64-linux-gnu/libtinfo.so.5
\end{verbatim}

\subsection{"'sys/cdefs.h' file not found" during vitis\_HLS compilation}
If Vitis HLS synthesis fails with the following error:
\begin{verbatim}
'sys/cdefs.h' file not found: /usr/include/features.h 
\end{verbatim}
You have to install the g++-multilib lib
\begin{verbatim}
sudo apt-get install g++-multilib
\end{verbatim}


\end{document}
