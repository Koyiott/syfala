\label{example}
\label{sec:example}
Imagine we want to implement on FPGA a filter-based sine wave oscillator. Such a sine wave is written in Faust in Fig.~\ref{fig:osc}. There is one controller which selects the oscillator frequency. Note the {\tt ``[knob:1]''} meta data that indicates that this controller will be associated to the first knob in case of hardware interface.

The computation of {\tt th}, {\tt c} and {\tt s} are depending on the frequency value, hence we expect all these variables to be computed at control rate, hence on the ARM, not on the FPGA. On the other hand, the computation of {\tt nlf2} is performed at each sample (sample rate) and will be implemented on the FPGA.


\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/sinewave-biquad-inlined.dsp}
  \end{boxedminipage}
  \caption{Filter-based sine wave oscillator in Faust used for illustrating the compilation process.}
  \label{fig:osc}
  \label{fig:biquad}
\end{figure}

The first step of the compilation flow is to generate a C++ program from the Faust code, this is done by executing {\tt make faust}. All the generated files that are related to the Faust IP are generated in the directory {\tt build/Faust\_v6}. In particular, the {\tt faust\_v6.cpp} is generated in {\tt build/Faust\_v6/Faust\_v6.cpp}.\\

\begin{boxedminipage}{1.03\textwidth}
  \small
\begin{verbatim}
v6.3-ex-sin> make faust
***************** Faust IP generation ***********************
*******  ../faust/sinewave-biquad-inlined.dsp -> faust_v6.cpp  ********
mkdir -p build/faust_v6_ip
faust -lang c -light -os2 -a fpga.cpp -uim -mcd 0 -o build/faust_v6_ip/faust_v6.cpp \
  ../faust/sinewave-biquad-inlined.dsp
cp configFAUST.h build/faust_v6_ip
v6.3-ex-sin>
\end{verbatim}
\end{boxedminipage}
~\\

\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/sinewave-biquad-inlined.cpp}
  \end{boxedminipage}
  \caption{Excerpt of {\tt faust\_v6.cpp} C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the FPGA target.}
  \label{fig:oscCode}
  \label{fig:biquadCode}
\end{figure}

An excerpt of file {\tt faust\_v6.cpp} is shown on Fig.~\ref{fig:oscCode}. One can first notice the structure {\tt mydsp} that is built for this example, the output  samples are computed by the {\tt computemydsp()} function. In this example, as the memory used is small, all variables are stored in Block Rams, hence declared here, in {\tt faust\_v6.cpp}. By looking at the body of the {\tt faust\_v6() function} (i.e. the ``main'' function),  one can see that for the first sample, the function {\tt instanceConstantsFromMemmydsp()} which copies the initialized constant {\tt fconst0} on the FPGA, then the {\tt computemydsp} is executed for all other samples. {\tt fRec} names are usually used for delay lines, the IOTA is used to implement delay line by circular buffers.

The second step of the compilation flow is to synthesize the Faust IP from the {\tt faust\_v6.cpp} using {\tt vitis\_hls}, this is done by typing {\tt make ip}.
The IP is generated in directory {\tt build/Faust\_v6\_ip/Faust\_v6}. The report of the HLS, indicating the size of the resulting IP and execution time in terms of FPGA cycles can be seen by typing {\tt make rpt}.
The execution time of the HLS is approximately 1 mn:\\
~\\
\begin{boxedminipage}{\textwidth}
  \small
\begin{verbatim}
v6.3-ex-sin> make ip
*********** HLS:  faust_v6 IP generation ************
Utilisation de Vitis_HLS
cd build && vitis_hls -f ../scripts/ip_v6.tcl

****** Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2020.2 (64-bit)
***
[...]

INFO: [HLS 200-802] Generated output file faust_v6_ip/faust_v6/impl/export.zip
INFO: [Common 17-206] Exiting vitis_hls at Thu Feb  3 09:24:29 2022...
v6.3-ex-sin> 
\end{verbatim}
\end{boxedminipage}
~\\

The next step is to synthesize the whole design that includes the Faust IP. This is done by executing {\tt make bitstream}. This command first builds the {\tt Faust\_v6\_project.xpr} vivado project from the TCL files and then executes it to produce the bitstream. The resulting file {\tt main\_wrapper.xsa} is generated in {\tt build/hw\_export} directory. One important point here is that the {\tt Faust\_v6\_project.xpr} can be opened directly with vivado 2020.2 GUI and modified and re-synthesized. This can be usefull for exploring other block designs (other parameters for the Faust IP for instance). The {\tt main\_wrapper.xsa} is also saved in a backup directory in order to be able to use alternatively several version of the the IP without re-synthesizing. This synthesis last about 15mn for Zybo Z10.\\

\begin{boxedminipage}{\textwidth}
  \small
\begin{verbatim}
v6.3-ex-sin> make bitstream 
****************************************************
******************* PROJECT CREATION ***************
mkdir -p build
cd build && vivado -mode batch -source ../scripts/project_v6.tcl -tclargs\
   --origin_dir $YOURDIR/v6.3-ex-sin
***** Vivado v2020.2 (64-bit)
[....]
source ../scripts/build_project_v6.tcl
[...]
*********** SYNTHESIS DONE ************************
**** main_wapprer.xsa generated in hw_export ******
mkdir -p backup && cp build/hw_export/main_wrapper.xsa \
   backup/sinewave-biquad-inlined_2022-02-03T10:20:44.xsa
v6.3-ex-sin>
\end{verbatim}
\end{boxedminipage}
~\\

Then you have to compile the application file that will run on the ARM processor. This application file is generated by the Faust compiler by using the {\tt arm.cpp} file. Its re-uses many software components developped for the Faust ecosystem and uses also the drivers provided by Xilinx in {\tt vivado}. Then the {\tt application\_v6.tcl} script is executed with {\tt xsct} (Xilinx Software Command-line Tool) which is an an interactive and scriptable command-line interface to Xilinx {\tt vitis} (formerly Xilinx SDK).

~\\
\begin{boxedminipage}{1.01\textwidth}
  \small
\begin{verbatim}
v6.3-ex-sin> make app
********************* ../faust/sinewave-biquad-inlined.dsp -> faust_v6_app.cpp *
*************
faust -i -lang cpp -os2 -mcd 0 -a arm.cpp ../faust/sinewave-biquad-inlined.dsp\
    -o build/faust_v6_application/generated_src/faust_v6_app.cpp
****************************************************
********** ARM Driver code compilation:**************
xsct ./scripts/application_v6.tcl
[...]
Finished building target: faust_v6_app.elf
Invoking: ARM v7 Print Size
arm-none-eabi-size faust_v6_app.elf  |tee "faust_v6_app.elf.size"
   text	   data	    bss	    dec	    hex	filename
 640400	   2904	2241180	2884484	 2c0384	faust_v6_app.elf
Finished building: faust_v6_app.elf.size
 
cp build/faust_v6_application/faust_v6_app/Debug/faust_v6_app.elf build/sw_export
v6.3-ex-sin>
\end{verbatim}
\end{boxedminipage}
~\\

An excerpt of file {\tt faust\_v6\_app.cpp} is shown on Fig.~\ref{fig:oscARM}. One can see that the {\tt mydsp} class private fields are exactly the same as the structure {\tt mydsp} of the Faust IP (Fig.~\ref{fig:oscCode}). This allow us to have coherent view of the IP, either from inside the FPGA or from the ARM processor. 

\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/faust_v6_app.cpp}
  \end{boxedminipage}
  \caption{Excerpt of C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the ARM application target.}
  \label{fig:oscARM}
\end{figure}


One can see that the {\tt control} method of {\tt mydsp} on the ARM processor (Fig.~\ref{fig:oscARM}) corresponds to the computations of variables {\tt th}, {\tt c} and {\tt s} of the Faust program of Fig.~\ref{fig:osc}. As we expected, the control rate computations are executed on the ARM. Then the structure {\tt ARMcontroller} defines the functions {\tt sendControlToFPGA()} and {\tt controlFPGA()}.

The function {\tt sendControlToFPGA()} is using Xilinx driver functions for accessing m-AXI port of the Faust IP (here {\tt fControl} and {\tt iControl} ports). The function {\tt controlFPGA()}  will first call {\tt \verb#fDSP->control()#} in order to get new values of the controllers from the hardware or software user interface, then it will call  {\tt sendControlFPGA()} to send these values to the Faust IP.

\begin{figure}[ht]
  \begin{boxedminipage}{\columnwidth}
    \tiny
    \verbatiminput{fig/faust_v6_app2.cpp}
  \end{boxedminipage}
  \caption{Excerpt of C++ code generated by the Faust compiler from the Faust code presented on Fig.~\ref{fig:biquad} when tuned for the ARM application target.}
  \label{fig:oscARM2}
\end{figure}

  Finally the ``main'' program of {\tt Faust\_v6\_app.cpp} can be seen on Fig.~\ref{fig:oscARM2}, it is an infinite loop calling permanently \verb#ARMController->controlFPGA()#



{\tt TODO: explain make controlUI}
